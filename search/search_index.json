{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to RCJ Soccer Sim! The RCJ Soccer Simulation Challenge will be an additional championship held at the 2021 RoboCup Junior. After a successful Demo competition in February, the next event will be the official Qualification Tournaments in May 2021, open for participation to any team that would like to register. The simulator is based on Webots . The associated repository provides both the \"automatic referee\" (which implements the Soccer Simulated Rules ) as well as a sample team of robots with some basic simulated strategy. How do I participate? In order to participate in the RCJ Soccer Simulation Challenge 2021 you must pass the Qualification stage that will be held centrally by the RCJ Soccer OC in May: Qualification Registration deadline: May 17'th 2021 Qualification Code submission deadline: May 24'th 2021 The registration form will be linked here in a few days. Please come back here for registration in late April. You can find more info at Registration & Qualification . How do I try this out? Setting up is easy: Getting started How to program your robot Code submission Please do not hesitate to ask any questions on the forum .","title":"Simulation Challenge 2021"},{"location":"#welcome-to-rcj-soccer-sim","text":"The RCJ Soccer Simulation Challenge will be an additional championship held at the 2021 RoboCup Junior. After a successful Demo competition in February, the next event will be the official Qualification Tournaments in May 2021, open for participation to any team that would like to register. The simulator is based on Webots . The associated repository provides both the \"automatic referee\" (which implements the Soccer Simulated Rules ) as well as a sample team of robots with some basic simulated strategy.","title":"Welcome to RCJ Soccer Sim!"},{"location":"#how-do-i-participate","text":"In order to participate in the RCJ Soccer Simulation Challenge 2021 you must pass the Qualification stage that will be held centrally by the RCJ Soccer OC in May: Qualification Registration deadline: May 17'th 2021 Qualification Code submission deadline: May 24'th 2021 The registration form will be linked here in a few days. Please come back here for registration in late April. You can find more info at Registration & Qualification .","title":"How do I participate?"},{"location":"#how-do-i-try-this-out","text":"Setting up is easy: Getting started How to program your robot Code submission Please do not hesitate to ask any questions on the forum .","title":"How do I try this out?"},{"location":"code_submission/","text":"Code submission To play the competition, the code that's powering the team's robots needs to get to the organizers. Let's talk a bit about how to do this. From controllers to a submission Suppose you have the folder structure which looks like this controllers/ \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py To submit it for the competition, there are two (well, maybe three) things we need to do: 1. Add a team name 2. (Optionally) add a team logo 3. Create a ZIP archive Add a team name The folder structure above does contain some code but it is not immediately obvious which team does it belong to. To make it obvious, please create a file called team_name.txt on the same level as robot/ . This file should contain a single line of text: the name of the team (up to 32 characters). The resulting folder structure would then look as follows: controllers/ \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py \u2514\u2500\u2500 team_name.txt (Optionally) add a team logo Note: This step is completely optional and you can just skip it -- your robot controllers will still work, even if you do not provide a custom logo for your team . If you'd like, you can optionally also add a custom logo for your team's robot. It will be used as an overlay on the robots in the simulator. The logo needs to be stored in the PNG format and located in a file called logo.png . If you choose to add one, the folder structure will look something like the following: controllers/ \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 logo.png \u2514\u2500\u2500 team_name.txt Create a ZIP archive This step is very simple: you just pick the directory that contains the code for your three robots, the team_name.txt file and optionally logo.png and put them all together into a single .ZIP file. There are many utilities that will do the job -- we can recommend 7-Zip . When you look into the resulting .ZIP file, the folder structure should look as follows: . \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 logo.png \u2514\u2500\u2500 team_name.txt Note that there is no controllers/ folder anymore -- the .ZIP file only contains a single robot/ folder and a single text file called team_name.txt (and optionally the logo.png image). Uploading your submission Once you have your .ZIP file ready, the only thing left is to submit it to the organizers. In practice, this generally means uploading it to a specific location that will be shared with all the participating teams well before the submission deadline. Things to keep in mind The resulting .ZIP file can be at most 10MB in size. The .ZIP file you submit needs to have exactly one first-level folder. That is, the folder structure after unzipping cannot look as follows: . \u251c\u2500\u2500 robot1 \u2502 \u2514\u2500\u2500 robot1.py \u251c\u2500\u2500 robot2 \u2502 \u2514\u2500\u2500 robot2.py The tournament organization software would not know which three robots to pick up and would most likely end up picking them up randomly. The organizers will run a code similarity detector on the submitted code. Yes, wheels really do not need to be reinvented but it would really not be fair to win a competition with something that's not primarily the team's own work. Submissions with significant overlap of duplicated code will not be permitted to compete in the competition. The code you submit will be open sourced at the end of the competition. If you managed to find a bug, have any question or ran into some problem, please do not hesitate to ask on the forum .","title":"Code submission"},{"location":"code_submission/#code-submission","text":"To play the competition, the code that's powering the team's robots needs to get to the organizers. Let's talk a bit about how to do this.","title":"Code submission"},{"location":"code_submission/#from-controllers-to-a-submission","text":"Suppose you have the folder structure which looks like this controllers/ \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py To submit it for the competition, there are two (well, maybe three) things we need to do: 1. Add a team name 2. (Optionally) add a team logo 3. Create a ZIP archive","title":"From controllers to a submission"},{"location":"code_submission/#add-a-team-name","text":"The folder structure above does contain some code but it is not immediately obvious which team does it belong to. To make it obvious, please create a file called team_name.txt on the same level as robot/ . This file should contain a single line of text: the name of the team (up to 32 characters). The resulting folder structure would then look as follows: controllers/ \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py \u2514\u2500\u2500 team_name.txt","title":"Add a team name"},{"location":"code_submission/#optionally-add-a-team-logo","text":"Note: This step is completely optional and you can just skip it -- your robot controllers will still work, even if you do not provide a custom logo for your team . If you'd like, you can optionally also add a custom logo for your team's robot. It will be used as an overlay on the robots in the simulator. The logo needs to be stored in the PNG format and located in a file called logo.png . If you choose to add one, the folder structure will look something like the following: controllers/ \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 logo.png \u2514\u2500\u2500 team_name.txt","title":"(Optionally) add a team logo"},{"location":"code_submission/#create-a-zip-archive","text":"This step is very simple: you just pick the directory that contains the code for your three robots, the team_name.txt file and optionally logo.png and put them all together into a single .ZIP file. There are many utilities that will do the job -- we can recommend 7-Zip . When you look into the resulting .ZIP file, the folder structure should look as follows: . \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 logo.png \u2514\u2500\u2500 team_name.txt Note that there is no controllers/ folder anymore -- the .ZIP file only contains a single robot/ folder and a single text file called team_name.txt (and optionally the logo.png image).","title":"Create a ZIP archive"},{"location":"code_submission/#uploading-your-submission","text":"Once you have your .ZIP file ready, the only thing left is to submit it to the organizers. In practice, this generally means uploading it to a specific location that will be shared with all the participating teams well before the submission deadline.","title":"Uploading your submission"},{"location":"code_submission/#things-to-keep-in-mind","text":"The resulting .ZIP file can be at most 10MB in size. The .ZIP file you submit needs to have exactly one first-level folder. That is, the folder structure after unzipping cannot look as follows: . \u251c\u2500\u2500 robot1 \u2502 \u2514\u2500\u2500 robot1.py \u251c\u2500\u2500 robot2 \u2502 \u2514\u2500\u2500 robot2.py The tournament organization software would not know which three robots to pick up and would most likely end up picking them up randomly. The organizers will run a code similarity detector on the submitted code. Yes, wheels really do not need to be reinvented but it would really not be fair to win a competition with something that's not primarily the team's own work. Submissions with significant overlap of duplicated code will not be permitted to compete in the competition. The code you submit will be open sourced at the end of the competition. If you managed to find a bug, have any question or ran into some problem, please do not hesitate to ask on the forum .","title":"Things to keep in mind"},{"location":"getting_started/","text":"How do I try this out? It's easy, you can set it up in about 10 minutes! (plus download time) Installation Install Python 3.7 (or higher) 64 bit from the official website (please make sure it is version 3.7 or higher for Windows, and 3.8 or higher if installing on MacOS or Linux). On Windows, please make sure your Python is referenced in Windows PATH by selecting the option \"Add Python 3.x to PATH\" during the installation. Check out this great installation guide if you need some help! Download Webots from their official website. Currently, version r2021a is stable with the Soccer Simulator. You can find detailed installation procedure on the official Webots Installation guide . Clone the rcj-soccer-sim repository to your computer by downloading the ZIP file from here or running git clone https://github.com/RoboCupJuniorTC/rcj-soccer-sim.git Finally, run Webots, go to Tools > Preferences > Python command and set it to python or python3 to point Webots to Python 3. Depending on your system, the reference to Python 3 can be via the command python or python3 . More information on how to configure Webots to work with Python can be found here . Running Soccer Sim Use Webots to open the downloaded soccer.wbt world located in the worlds directory (via File > Open World ) Run/pause the simulation by clicking the corresponding buttons on the top-part of Webots window. Note that the controllers that are responsible for the various robots on the field can be found in the controllers/ directory. Notes A specific webots world can be executed directly from the command line as follows: webots --mode=run worlds/soccer.wbt Which allows for at least some automation. Further info can be found in the docs . The sample players as well as the \"automatic referee\" are implemented in Python, which should allow for easily updating the code to match the rules and avoid any compilation issues.","title":"Getting Started"},{"location":"getting_started/#how-do-i-try-this-out","text":"It's easy, you can set it up in about 10 minutes! (plus download time)","title":"How do I try this out?"},{"location":"getting_started/#installation","text":"Install Python 3.7 (or higher) 64 bit from the official website (please make sure it is version 3.7 or higher for Windows, and 3.8 or higher if installing on MacOS or Linux). On Windows, please make sure your Python is referenced in Windows PATH by selecting the option \"Add Python 3.x to PATH\" during the installation. Check out this great installation guide if you need some help! Download Webots from their official website. Currently, version r2021a is stable with the Soccer Simulator. You can find detailed installation procedure on the official Webots Installation guide . Clone the rcj-soccer-sim repository to your computer by downloading the ZIP file from here or running git clone https://github.com/RoboCupJuniorTC/rcj-soccer-sim.git Finally, run Webots, go to Tools > Preferences > Python command and set it to python or python3 to point Webots to Python 3. Depending on your system, the reference to Python 3 can be via the command python or python3 . More information on how to configure Webots to work with Python can be found here .","title":"Installation"},{"location":"getting_started/#running-soccer-sim","text":"Use Webots to open the downloaded soccer.wbt world located in the worlds directory (via File > Open World ) Run/pause the simulation by clicking the corresponding buttons on the top-part of Webots window. Note that the controllers that are responsible for the various robots on the field can be found in the controllers/ directory.","title":"Running Soccer Sim"},{"location":"getting_started/#notes","text":"A specific webots world can be executed directly from the command line as follows: webots --mode=run worlds/soccer.wbt Which allows for at least some automation. Further info can be found in the docs . The sample players as well as the \"automatic referee\" are implemented in Python, which should allow for easily updating the code to match the rules and avoid any compilation issues.","title":"Notes"},{"location":"how_to_robot/","text":"How to program your robot Controllers Each object in the simulation world can be controlled by a program. This program is called Controller . Each robot should have exactly one controller, implemented as a Python3 program. There is an invisible referee object in the simulation, which takes care of controlling the game and checking the rules. The controllers are located in the controllers directory. The name of the controller must be located in a subfolder with the same name (i.e. my_controller/my_controller.py ) and this name ought to be specified in soccer.wbt file. Hello world, robot! We have prepared a few sample robot controllers. They can be found in the controllers directory. The controllers for the robots of blue team are located in rcj_soccer_team_blue folder and for the robots of yellow team in rcj_soccer_team_yellow folder, respectively. Team folders contain a file called rcj_soccer_team_blue.py (blue team) or rcj_soccer_team_yellow.py (yellow team). Each of the robots initially runs this file. Based on the unique identifier of the robot (which can be 1 , 2 or 3 ) we initialize the code for the particular robot. Script for determining and initializing the robot controller A sample initial file might look as follows: from controller import Robot from robot1 import MyRobot1 from robot2 import MyRobot2 from robot3 import MyRobot3 robot = Robot () name = robot . getName () robot_number = int ( name [ 1 ]) if robot_number == 1 : robot_controller = MyRobot1 ( robot ) elif robot_number == 2 : robot_controller = MyRobot2 ( robot ) else : robot_controller = MyRobot3 ( robot ) robot_controller . run () Let's describe a file for determining robot's name and running specific controller. from controller import Robot The Robot class is required to be imported because this is the only way we are able to controll the robot. The Robot class is shipped together with Webots. from robot1 import MyRobot1 from robot2 import MyRobot2 from robot3 import MyRobot3 Since all of robot controllers are located in the same directory, we can easily import them. robot = Robot () name = robot . getName () Initialize robot instance and get the name of the robot. The name is one of the following {\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"} . robot_number = int ( name [ 1 ]) if robot_number == 1 : robot_controller = MyRobot1 ( robot ) elif robot_number == 2 : robot_controller = MyRobot2 ( robot ) else : robot_controller = MyRobot3 ( robot ) By checking the second character in the name, we can easily get the number identifier of the robot and initialize its controller appropriately. robot_controller . run () We just call the method run in order to execute the code for the specific robot we initialized previously. Robot controller Let's put together a simple program to showcase how you can go about programming a robot. import struct TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) class MyRobot : def __init__ ( self , robot ): self . robot = robot self . name = self . robot . getName () self . receiver = self . robot . getDevice ( \"receiver\" ) self . receiver . enable ( TIME_STEP ) self . left_motor = self . robot . getDevice ( \"left wheel motor\" ) self . right_motor = self . robot . getDevice ( \"right wheel motor\" ) self . left_motor . setPosition ( float ( '+inf' )) self . right_motor . setPosition ( float ( '+inf' )) self . left_motor . setVelocity ( 0.0 ) self . right_motor . setVelocity ( 0.0 ) def get_new_data ( self ): packet = self . receiver . getData () self . receiver . nextPacket () struct_fmt = 'ddd' * 6 + 'dd' + '?' unpacked = struct . unpack ( struct_fmt , packet ) data = {} for i , r in enumerate ( ROBOT_NAMES ): data [ r ] = { \"x\" : unpacked [ 3 * i ], \"y\" : unpacked [ 3 * i + 1 ], \"orientation\" : unpacked [ 3 * i + 2 ] } ball_data_index = 3 * N_ROBOTS data [ \"ball\" ] = { \"x\" : unpacked [ ball_data_index ], \"y\" : unpacked [ ball_data_index + 1 ] } waiting_for_kickoff_data_index = ball_data_index + 2 data [ \"waiting_for_kickoff\" ] = unpacked [ waiting_for_kickoff_data_index ] return data def run ( self ): while self . robot . step ( TIME_STEP ) != - 1 : if self . receiver . getQueueLength () > 0 : data = self . get_new_data () # Get the position of our robot robot_pos = data [ self . name ] # Get the position of the ball ball_pos = data [ 'ball' ] self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) Let's explain the code in detail: import struct This library is a built-in Python library , which is required to unpack the data sent by the supervisor. TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) We also define some useful constants, whose values will be used later. class MyRobot : You can wrap the program into the class as we did. The benefit of OOP ( Object Oriented Programming ) is that you can later reuse the same common class throughout your controllers and therefore make the code easier to read. We are going to continue with our OOP approach. def __init__ ( self , robot ): self . robot = Robot self . name = self . robot . getName () ... The __init__ function is something like a constructor of the class and is called when an instance of the MyRobot object is created. We use this function to initialize some important variables. The most important one is the Robot instance, which allows us to get access to the so called Webots devices like motor (for controlling the speed) or receiver (for reading data from Supervisor). The name and the team of your robot can be determined by calling self.robot.getName() . It will give you one of {\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"} . The first letter determines the team (\"Blue\", \"Yellow\"), while the second one is the robot's identifier. def get_new_data ( self ): ... We are not going to explain this deeply. This function is to parse the incoming data from supervisor. Feel free to copy and use it. The resulting dictionary contains positions of all of the robots as well as the position of the ball. Moreover, it contains information whether the goal gets scored and we are waiting for new kickoff. In case the goal gets scored, the value is True and is reset to False when the referee fires new kickoff. def run ( self ): This is the method which contains the logic for controlling the robot. As mentioned previously, it is called by our initialization script. while self . robot . step ( TIME_STEP ) != - 1 : The step function is crucial and must be used in every controller. This function synchronizes the sensor and actuator data between Webots and the controllers. if self . receiver . getQueueLength () > 0 : Before reading data, it is important to check if there is actually something in the queue that we can read. data = self . get_new_data () robot_pos = data [ self . name ] ball_pos = data [ 'ball' ] self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) And finally, after reading the new data received from supervisor, we do some calculations and set the speed of the motors. Importing shared code Each team consists of three robots. These robots might share some of the code and it is actually a good practice not to duplicate code all over the place. Imagine you have the folder structure which looks like this controllers/ \u251c\u2500\u2500 team_name/ \u2502 \u2514\u2500\u2500 team_name.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py and within robot1.py , robot2.py and robot3.py you want to import some useful code from utils.py . You can easily import it by calling import utils and use the shared code rather than copying it into each of the controllers. Do not import anything from team_name.py file, otherwise you might get cyclic import problem. Supported external libraries In general, the whole Python's standard library can be used in the robot's programs. Furthermore, to make the computations easier, the Soccer Sim environment supports the following two Python libraries that are normally used for what's called \"scientific computing\": numpy (version 1.20.2) scipy (version 1.6.3)","title":"How to program your robot"},{"location":"how_to_robot/#how-to-program-your-robot","text":"","title":"How to program your robot"},{"location":"how_to_robot/#controllers","text":"Each object in the simulation world can be controlled by a program. This program is called Controller . Each robot should have exactly one controller, implemented as a Python3 program. There is an invisible referee object in the simulation, which takes care of controlling the game and checking the rules. The controllers are located in the controllers directory. The name of the controller must be located in a subfolder with the same name (i.e. my_controller/my_controller.py ) and this name ought to be specified in soccer.wbt file.","title":"Controllers"},{"location":"how_to_robot/#hello-world-robot","text":"We have prepared a few sample robot controllers. They can be found in the controllers directory. The controllers for the robots of blue team are located in rcj_soccer_team_blue folder and for the robots of yellow team in rcj_soccer_team_yellow folder, respectively. Team folders contain a file called rcj_soccer_team_blue.py (blue team) or rcj_soccer_team_yellow.py (yellow team). Each of the robots initially runs this file. Based on the unique identifier of the robot (which can be 1 , 2 or 3 ) we initialize the code for the particular robot.","title":"Hello world, robot!"},{"location":"how_to_robot/#script-for-determining-and-initializing-the-robot-controller","text":"A sample initial file might look as follows: from controller import Robot from robot1 import MyRobot1 from robot2 import MyRobot2 from robot3 import MyRobot3 robot = Robot () name = robot . getName () robot_number = int ( name [ 1 ]) if robot_number == 1 : robot_controller = MyRobot1 ( robot ) elif robot_number == 2 : robot_controller = MyRobot2 ( robot ) else : robot_controller = MyRobot3 ( robot ) robot_controller . run () Let's describe a file for determining robot's name and running specific controller. from controller import Robot The Robot class is required to be imported because this is the only way we are able to controll the robot. The Robot class is shipped together with Webots. from robot1 import MyRobot1 from robot2 import MyRobot2 from robot3 import MyRobot3 Since all of robot controllers are located in the same directory, we can easily import them. robot = Robot () name = robot . getName () Initialize robot instance and get the name of the robot. The name is one of the following {\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"} . robot_number = int ( name [ 1 ]) if robot_number == 1 : robot_controller = MyRobot1 ( robot ) elif robot_number == 2 : robot_controller = MyRobot2 ( robot ) else : robot_controller = MyRobot3 ( robot ) By checking the second character in the name, we can easily get the number identifier of the robot and initialize its controller appropriately. robot_controller . run () We just call the method run in order to execute the code for the specific robot we initialized previously.","title":"Script for determining and initializing the robot controller"},{"location":"how_to_robot/#robot-controller","text":"Let's put together a simple program to showcase how you can go about programming a robot. import struct TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) class MyRobot : def __init__ ( self , robot ): self . robot = robot self . name = self . robot . getName () self . receiver = self . robot . getDevice ( \"receiver\" ) self . receiver . enable ( TIME_STEP ) self . left_motor = self . robot . getDevice ( \"left wheel motor\" ) self . right_motor = self . robot . getDevice ( \"right wheel motor\" ) self . left_motor . setPosition ( float ( '+inf' )) self . right_motor . setPosition ( float ( '+inf' )) self . left_motor . setVelocity ( 0.0 ) self . right_motor . setVelocity ( 0.0 ) def get_new_data ( self ): packet = self . receiver . getData () self . receiver . nextPacket () struct_fmt = 'ddd' * 6 + 'dd' + '?' unpacked = struct . unpack ( struct_fmt , packet ) data = {} for i , r in enumerate ( ROBOT_NAMES ): data [ r ] = { \"x\" : unpacked [ 3 * i ], \"y\" : unpacked [ 3 * i + 1 ], \"orientation\" : unpacked [ 3 * i + 2 ] } ball_data_index = 3 * N_ROBOTS data [ \"ball\" ] = { \"x\" : unpacked [ ball_data_index ], \"y\" : unpacked [ ball_data_index + 1 ] } waiting_for_kickoff_data_index = ball_data_index + 2 data [ \"waiting_for_kickoff\" ] = unpacked [ waiting_for_kickoff_data_index ] return data def run ( self ): while self . robot . step ( TIME_STEP ) != - 1 : if self . receiver . getQueueLength () > 0 : data = self . get_new_data () # Get the position of our robot robot_pos = data [ self . name ] # Get the position of the ball ball_pos = data [ 'ball' ] self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) Let's explain the code in detail: import struct This library is a built-in Python library , which is required to unpack the data sent by the supervisor. TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) We also define some useful constants, whose values will be used later. class MyRobot : You can wrap the program into the class as we did. The benefit of OOP ( Object Oriented Programming ) is that you can later reuse the same common class throughout your controllers and therefore make the code easier to read. We are going to continue with our OOP approach. def __init__ ( self , robot ): self . robot = Robot self . name = self . robot . getName () ... The __init__ function is something like a constructor of the class and is called when an instance of the MyRobot object is created. We use this function to initialize some important variables. The most important one is the Robot instance, which allows us to get access to the so called Webots devices like motor (for controlling the speed) or receiver (for reading data from Supervisor). The name and the team of your robot can be determined by calling self.robot.getName() . It will give you one of {\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"} . The first letter determines the team (\"Blue\", \"Yellow\"), while the second one is the robot's identifier. def get_new_data ( self ): ... We are not going to explain this deeply. This function is to parse the incoming data from supervisor. Feel free to copy and use it. The resulting dictionary contains positions of all of the robots as well as the position of the ball. Moreover, it contains information whether the goal gets scored and we are waiting for new kickoff. In case the goal gets scored, the value is True and is reset to False when the referee fires new kickoff. def run ( self ): This is the method which contains the logic for controlling the robot. As mentioned previously, it is called by our initialization script. while self . robot . step ( TIME_STEP ) != - 1 : The step function is crucial and must be used in every controller. This function synchronizes the sensor and actuator data between Webots and the controllers. if self . receiver . getQueueLength () > 0 : Before reading data, it is important to check if there is actually something in the queue that we can read. data = self . get_new_data () robot_pos = data [ self . name ] ball_pos = data [ 'ball' ] self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) And finally, after reading the new data received from supervisor, we do some calculations and set the speed of the motors.","title":"Robot controller"},{"location":"how_to_robot/#importing-shared-code","text":"Each team consists of three robots. These robots might share some of the code and it is actually a good practice not to duplicate code all over the place. Imagine you have the folder structure which looks like this controllers/ \u251c\u2500\u2500 team_name/ \u2502 \u2514\u2500\u2500 team_name.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py and within robot1.py , robot2.py and robot3.py you want to import some useful code from utils.py . You can easily import it by calling import utils and use the shared code rather than copying it into each of the controllers. Do not import anything from team_name.py file, otherwise you might get cyclic import problem.","title":"Importing shared code"},{"location":"how_to_robot/#supported-external-libraries","text":"In general, the whole Python's standard library can be used in the robot's programs. Furthermore, to make the computations easier, the Soccer Sim environment supports the following two Python libraries that are normally used for what's called \"scientific computing\": numpy (version 1.20.2) scipy (version 1.6.3)","title":"Supported external libraries"},{"location":"how_to_run_sim/","text":"Running the simulator Note: This document is intended for the organizers of events in which the RCJ Soccer Sim is to be used This document outlines how the RoboCupJunior Soccer Sim can be used to simulate a match in a \"headless\" way. In other words, it shows how you can go from having the code for two teams and the RoboCupJunior Soccer Sim code to getting an output in form of either an MPEG-4 video or a HTML site. Input Source code for the yellow team Source code for the blue team RoboCupJunior Soccer Sim Output MPEG-4 video and/or HTML site JSON file containing all the important events happened during the game Preliminaries This guide makes a couple of assumptions: You use an UNIX-like environment (i.e. something like Linux or macOS) You have Webots installed and cloned the rcj-soccer-sim repository locally (check the Getting Started guide on how to do so) Running Soccer Sim (and Webots) in Automatic Mode As Webots docs state, it can also be started from a Terminal, or a command line prompt. The most basic command would look as follows: webots --mode=fast worlds/soccer.wbt This opens up Webots and automatically starts the game in the GUI. You can then either pause the game, restart it or even manually setup the video/HTML export. Soccer Sim's referee has the ability to automatically start the recording and stop the execution when it finishes. To do so, the RCJ_SIM_AUTO_MODE environment variable needs to be set (the value doesn't matter but we suggest True or something of that sort). Furthermore, to make sure the game is recorded, a recording format needs to be specified. This is done via the RCJ_SIM_REC_FORMATS environment variable and all the options are documented in the section below. In summary, to automatically run the world/soccer.wbt world file (the Soccer environment) and record the output in HTML format, the following command can be used: RCJ_SIM_AUTO_MODE=True RCJ_SIM_REC_FORMATS=x3d webots --mode=fast worlds/soccer.wbt Running Soccer Sim in Docker To simplify the automatic running of games, Soccer Sim can also be executed inside a Docker container. We generally recommend using the offical container provided by Webots and mentioned in the official guide . Assuming the rcj-soccer-sim repository is located in the current directory, running Soccer Sim within docker is as simple as executing docker run \\ -v $(pwd)/rcj-soccer-sim:/rcj-soccer-sim \\ -e RCJ_SIM_AUTO_MODE=True \\ -e RCJ_SIM_REC_FORMATS=x3d \\ cyberbotics/webots:latest /rcj-soccer-sim/run-in-docker.sh /rcj-soccer-sim/worlds/soccer.wbt Let us briefly discuss the respective lines. On the first one the docker command starts the Docker container, on the second one, the rcj-soccer-sim folder in the current directory is mapped to /rcj-soccer-sim in the container, on the following two the RCJ_SIM_AUTO_MODE and RCJ_SIM_REC_FORMATS environment variables are being set and on the last one the worlds/soccer.wbt world from the rcj-soccer-sim repository is executed in the Webex environment using the run-in-docker.sh script (also part of the very same repository). Extracting the recorded output By default, the output (recording and reflog) of a match is saved in the reflog/ folder in controllers/rcj_soccer_referee_supervisor/ of the rcj-soccer-sim repository. This is relatively inconveniet when it comes to running multiple games and getting data out of the Docker container and hence the path can be changed using the RCJ_SIM_OUTPUT_PATH environment variable. The command below redirects the output to the /tmp/outputs directory inside the container and maps it to the outputs/ directory in the current working directory on the host: docker run \\ -v $(pwd)/rcj-soccer-sim:/rcj-soccer-sim \\ -v $(pwd)/outputs:/tmp/outputs \\ -e RCJ_SIM_AUTO_MODE=True \\ -e RCJ_SIM_REC_FORMATS=x3d \\ -e RCJ_SIM_OUTPUT_PATH=/tmp/outputs/ \\ cyberbotics/webots:latest /rcj-soccer-sim/run-in-docker.sh /rcj-soccer-sim/worlds/soccer.wbt Environment variables The full list of environment variables supported by the Soccer Sim can be found below: RCJ_SIM_AUTO_MODE : If set (to any value), the simulation speed is set to fast, the recorders are started at the beginning and the application is automatically closed after the match is finished. Not set by default. RCJ_SIM_MATCH_TIME : Sets the number of seconds for which the match is to be played. Defaults to 600 (10 minutes). RCJ_SIM_REC_FORMATS : When set, the Soccer Sim starts a recording in these formats. The available options are mp4 and x3d . Multiple options can be set as well, separated by a comma. Not set by default. RCJ_SIM_OUTPUT_PATH : The path where the reflog outputs as well as the recordings are to be saved. Defaults to the reflog/ folder in controllers/rcj_soccer_referee_supervisor/ . Internal team-related variables: RCJ_SIM_TEAM_YELLOW_NAME : The name of the yellow team. Defaults to \"The Yellows\". RCJ_SIM_TEAM_Y_INITIAL_SCORE : The initial score of the yellow team. Defaults to 0. RCJ_SIM_TEAM_BLUE_NAME : The name of the blue team. Defaults to \"The Blues\". RCJ_SIM_TEAM_B_INITIAL_SCORE : The initial score of the blue team. Defaults to 0. RCJ_SIM_TEAM_YELLOW_ID : The ID of the yellow team used for internal identification. Defaults to \"The Yellows\". RCJ_SIM_TEAM_BLUE_ID : The ID of the yellow team used for internal identification. Defaults to \"The Blues\". RCJ_SIM_MATCH_ID : The ID of the match used for internal identification. Defaults to 1. RCJ_SIM_HALF_ID : The ID of the half time used for internal identification. Defaults to 1.","title":"Running the simulator"},{"location":"how_to_run_sim/#running-the-simulator","text":"Note: This document is intended for the organizers of events in which the RCJ Soccer Sim is to be used This document outlines how the RoboCupJunior Soccer Sim can be used to simulate a match in a \"headless\" way. In other words, it shows how you can go from having the code for two teams and the RoboCupJunior Soccer Sim code to getting an output in form of either an MPEG-4 video or a HTML site. Input Source code for the yellow team Source code for the blue team RoboCupJunior Soccer Sim Output MPEG-4 video and/or HTML site JSON file containing all the important events happened during the game","title":"Running the simulator"},{"location":"how_to_run_sim/#preliminaries","text":"This guide makes a couple of assumptions: You use an UNIX-like environment (i.e. something like Linux or macOS) You have Webots installed and cloned the rcj-soccer-sim repository locally (check the Getting Started guide on how to do so)","title":"Preliminaries"},{"location":"how_to_run_sim/#running-soccer-sim-and-webots-in-automatic-mode","text":"As Webots docs state, it can also be started from a Terminal, or a command line prompt. The most basic command would look as follows: webots --mode=fast worlds/soccer.wbt This opens up Webots and automatically starts the game in the GUI. You can then either pause the game, restart it or even manually setup the video/HTML export. Soccer Sim's referee has the ability to automatically start the recording and stop the execution when it finishes. To do so, the RCJ_SIM_AUTO_MODE environment variable needs to be set (the value doesn't matter but we suggest True or something of that sort). Furthermore, to make sure the game is recorded, a recording format needs to be specified. This is done via the RCJ_SIM_REC_FORMATS environment variable and all the options are documented in the section below. In summary, to automatically run the world/soccer.wbt world file (the Soccer environment) and record the output in HTML format, the following command can be used: RCJ_SIM_AUTO_MODE=True RCJ_SIM_REC_FORMATS=x3d webots --mode=fast worlds/soccer.wbt","title":"Running Soccer Sim (and Webots) in Automatic Mode"},{"location":"how_to_run_sim/#running-soccer-sim-in-docker","text":"To simplify the automatic running of games, Soccer Sim can also be executed inside a Docker container. We generally recommend using the offical container provided by Webots and mentioned in the official guide . Assuming the rcj-soccer-sim repository is located in the current directory, running Soccer Sim within docker is as simple as executing docker run \\ -v $(pwd)/rcj-soccer-sim:/rcj-soccer-sim \\ -e RCJ_SIM_AUTO_MODE=True \\ -e RCJ_SIM_REC_FORMATS=x3d \\ cyberbotics/webots:latest /rcj-soccer-sim/run-in-docker.sh /rcj-soccer-sim/worlds/soccer.wbt Let us briefly discuss the respective lines. On the first one the docker command starts the Docker container, on the second one, the rcj-soccer-sim folder in the current directory is mapped to /rcj-soccer-sim in the container, on the following two the RCJ_SIM_AUTO_MODE and RCJ_SIM_REC_FORMATS environment variables are being set and on the last one the worlds/soccer.wbt world from the rcj-soccer-sim repository is executed in the Webex environment using the run-in-docker.sh script (also part of the very same repository).","title":"Running Soccer Sim in Docker"},{"location":"how_to_run_sim/#extracting-the-recorded-output","text":"By default, the output (recording and reflog) of a match is saved in the reflog/ folder in controllers/rcj_soccer_referee_supervisor/ of the rcj-soccer-sim repository. This is relatively inconveniet when it comes to running multiple games and getting data out of the Docker container and hence the path can be changed using the RCJ_SIM_OUTPUT_PATH environment variable. The command below redirects the output to the /tmp/outputs directory inside the container and maps it to the outputs/ directory in the current working directory on the host: docker run \\ -v $(pwd)/rcj-soccer-sim:/rcj-soccer-sim \\ -v $(pwd)/outputs:/tmp/outputs \\ -e RCJ_SIM_AUTO_MODE=True \\ -e RCJ_SIM_REC_FORMATS=x3d \\ -e RCJ_SIM_OUTPUT_PATH=/tmp/outputs/ \\ cyberbotics/webots:latest /rcj-soccer-sim/run-in-docker.sh /rcj-soccer-sim/worlds/soccer.wbt","title":"Extracting the recorded output"},{"location":"how_to_run_sim/#environment-variables","text":"The full list of environment variables supported by the Soccer Sim can be found below: RCJ_SIM_AUTO_MODE : If set (to any value), the simulation speed is set to fast, the recorders are started at the beginning and the application is automatically closed after the match is finished. Not set by default. RCJ_SIM_MATCH_TIME : Sets the number of seconds for which the match is to be played. Defaults to 600 (10 minutes). RCJ_SIM_REC_FORMATS : When set, the Soccer Sim starts a recording in these formats. The available options are mp4 and x3d . Multiple options can be set as well, separated by a comma. Not set by default. RCJ_SIM_OUTPUT_PATH : The path where the reflog outputs as well as the recordings are to be saved. Defaults to the reflog/ folder in controllers/rcj_soccer_referee_supervisor/ . Internal team-related variables: RCJ_SIM_TEAM_YELLOW_NAME : The name of the yellow team. Defaults to \"The Yellows\". RCJ_SIM_TEAM_Y_INITIAL_SCORE : The initial score of the yellow team. Defaults to 0. RCJ_SIM_TEAM_BLUE_NAME : The name of the blue team. Defaults to \"The Blues\". RCJ_SIM_TEAM_B_INITIAL_SCORE : The initial score of the blue team. Defaults to 0. RCJ_SIM_TEAM_YELLOW_ID : The ID of the yellow team used for internal identification. Defaults to \"The Yellows\". RCJ_SIM_TEAM_BLUE_ID : The ID of the yellow team used for internal identification. Defaults to \"The Blues\". RCJ_SIM_MATCH_ID : The ID of the match used for internal identification. Defaults to 1. RCJ_SIM_HALF_ID : The ID of the half time used for internal identification. Defaults to 1.","title":"Environment variables"},{"location":"qualification/","text":"Simulation Challenge: Registration & Qualification Overview The RCJ Soccer Simulation Challenge will be an additional championship played at the 2021 RCJ and will be held in June, fully virtual. In order to participate in the June Tournament , you need to successfully qualify in one of our Qualification Tournaments in May. The qualification will be held centrally by the RCJ Soccer OC. You will need to register twice: once for the Qualification Tournament, and again for the final June Tournament (if qualified) Timeline In order to participate in the RCJ Soccer Simulation Challenge 2021 you must pass the Qualification stage that will be held centrally by the RCJ Soccer OC in May. Qualification registration deadline: May 17'th 2021 Qualification code submission deadline: May 24'th 2021 We will publish the qualification results on June 2nd. If qualified, you will need to register again for the 2021 RCJ Championships in June: June registration deadline: June 7'th 2021 June code submission deadline: June 14'th 2021 (yes you can send in new code!) Note: Registering for the Qualification Tournament will be free from charge. The registration and code submission forms for the Qualification Tournament will be linked here in a few days. Please come back here for registration late April. Qualification Tournaments There will be 3 virtual Super-Regional Qualification Tournaments in May, one for each region: Americas African + Europe Asia + Pacific After the registration, teams will be assigned to their Super-Regional automatically. Each Super-Regional will play 7 rounds of Swiss System . After those rounds, the best team from each country will automatically qualify for the Tournament in June. Of the remaining teams, the best teams in each Super-Regional (top-of-the-table) will also qualify, \"per wildcard\". Those wildcards will be given independently of country to the best teams. The number of wildcards will be proportional to the size of the Super-Regional, meaning the largest Super-Regional will receive the most wildcards (but 2/3rd of all wildcards at most). Note: This may result in some countries sending more teams than other countries. On the other hand, each country will be able to send at least 1 team. Since this is the first year of RCJ Soccer Sim, and since there is no way to approximate the number of teams per country before the registration deadline, a fixed-sized quota does not work. Note: This qualification process is for RCJ Soccer Simulation Challenge only! It does not apply to RCJ Soccer Lightweight League or RCJ Soccer Open League ! Please follow the official channels for qualification information on Lightweight League and Open League .","title":"Registration & Qualification"},{"location":"qualification/#simulation-challenge-registration-qualification","text":"","title":"Simulation Challenge: Registration &amp; Qualification"},{"location":"qualification/#overview","text":"The RCJ Soccer Simulation Challenge will be an additional championship played at the 2021 RCJ and will be held in June, fully virtual. In order to participate in the June Tournament , you need to successfully qualify in one of our Qualification Tournaments in May. The qualification will be held centrally by the RCJ Soccer OC. You will need to register twice: once for the Qualification Tournament, and again for the final June Tournament (if qualified)","title":"Overview"},{"location":"qualification/#timeline","text":"In order to participate in the RCJ Soccer Simulation Challenge 2021 you must pass the Qualification stage that will be held centrally by the RCJ Soccer OC in May. Qualification registration deadline: May 17'th 2021 Qualification code submission deadline: May 24'th 2021 We will publish the qualification results on June 2nd. If qualified, you will need to register again for the 2021 RCJ Championships in June: June registration deadline: June 7'th 2021 June code submission deadline: June 14'th 2021 (yes you can send in new code!) Note: Registering for the Qualification Tournament will be free from charge. The registration and code submission forms for the Qualification Tournament will be linked here in a few days. Please come back here for registration late April.","title":"Timeline"},{"location":"qualification/#qualification-tournaments","text":"There will be 3 virtual Super-Regional Qualification Tournaments in May, one for each region: Americas African + Europe Asia + Pacific After the registration, teams will be assigned to their Super-Regional automatically. Each Super-Regional will play 7 rounds of Swiss System . After those rounds, the best team from each country will automatically qualify for the Tournament in June. Of the remaining teams, the best teams in each Super-Regional (top-of-the-table) will also qualify, \"per wildcard\". Those wildcards will be given independently of country to the best teams. The number of wildcards will be proportional to the size of the Super-Regional, meaning the largest Super-Regional will receive the most wildcards (but 2/3rd of all wildcards at most). Note: This may result in some countries sending more teams than other countries. On the other hand, each country will be able to send at least 1 team. Since this is the first year of RCJ Soccer Sim, and since there is no way to approximate the number of teams per country before the registration deadline, a fixed-sized quota does not work. Note: This qualification process is for RCJ Soccer Simulation Challenge only! It does not apply to RCJ Soccer Lightweight League or RCJ Soccer Open League ! Please follow the official channels for qualification information on Lightweight League and Open League .","title":"Qualification Tournaments"},{"location":"rules/","text":"RCJ Soccer Simulation Rules 2021 The rules include everything you need to know about the behaviour of the artificial referee and about what you can and cannot do. For any questions, please reach out to the TC on the forum . You can download the rule here: RCJ Soccer Simulation Rules 2021","title":"Rules"},{"location":"rules/#rcj-soccer-simulation-rules-2021","text":"The rules include everything you need to know about the behaviour of the artificial referee and about what you can and cannot do. For any questions, please reach out to the TC on the forum . You can download the rule here: RCJ Soccer Simulation Rules 2021","title":"RCJ Soccer Simulation Rules 2021"}]}